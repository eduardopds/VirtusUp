# -*- coding: utf-8 -*-
"""Copy of Exercicio_busca_cega.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pbt7BTZ_QJuF5arx6mmV2LHCIMtNeU0N
"""

import networkx as nx
import matplotlib.pyplot as plt
from matplotlib import lines

from ipywidgets import interact
import ipywidgets as widgets

from collections import deque

import heapq
import numpy as np

import time

"""# Exercício sobre busca cega

Para este exercício, vamos implementar alguns mecanismos de busca cega, bem como fazer análises comparativas dos mesmos.

## Algumas funções necessárias para realizar as buscas cegas
"""

def display_visual(graph_data, algorithm=None, problem=None):
    initial_node_colors = graph_data['node_colors']
    def slider_callback(iteration):
        # don't show graph for the first time running the cell calling this function
        try:
            show_map(graph_data, node_colors=all_node_colors[iteration])
        except:
            pass
    def visualize_callback(Visualize):
        if Visualize is True:
            button.value = False

            global all_node_colors

            iterations, all_node_colors, node = algorithm(problem)
            solution = node.solution()
            all_node_colors.append(final_path_colors(all_node_colors[0], problem, solution))

            slider.max = len(all_node_colors) - 1

            for i in range(slider.max + 1):
                slider.value = i
                 #time.sleep(.5)

    slider = widgets.IntSlider(min=0, max=1, step=1, value=0)
    slider_visual = widgets.interactive(slider_callback, iteration=slider)
    display(slider_visual)

    button = widgets.ToggleButton(value=False)
    button_visual = widgets.interactive(visualize_callback, Visualize=button)
    display(button_visual)
        
def show_map(graph_data, node_colors = None):
    G = nx.Graph(graph_data['graph_dict'])
    node_colors = node_colors or graph_data['node_colors']
    node_positions = graph_data['node_positions']
    node_label_pos = graph_data['node_label_positions']
    edge_weights= graph_data['edge_weights']
    
    # set the size of the plot
    plt.figure(figsize=(18,13))
    # draw the graph (both nodes and edges) with locations from romania_locations
    nx.draw(G, pos={k: node_positions[k] for k in G.nodes()},
            node_color=[node_colors[node] for node in G.nodes()], linewidths=0.3, edgecolors='k')

    # draw labels for nodes
    node_label_handles = nx.draw_networkx_labels(G, pos=node_label_pos, font_size=14)
    
    # add a white bounding box behind the node labels
    [label.set_bbox(dict(facecolor='white', edgecolor='none')) for label in node_label_handles.values()]

    # add edge lables to the graph
    nx.draw_networkx_edge_labels(G, pos=node_positions, edge_labels=edge_weights, font_size=14)
    
    # add a legend
    white_circle = lines.Line2D([], [], color="white", marker='o', markersize=15, markerfacecolor="white")
    orange_circle = lines.Line2D([], [], color="orange", marker='o', markersize=15, markerfacecolor="orange")
    red_circle = lines.Line2D([], [], color="red", marker='o', markersize=15, markerfacecolor="red")
    gray_circle = lines.Line2D([], [], color="gray", marker='o', markersize=15, markerfacecolor="gray")
    green_circle = lines.Line2D([], [], color="green", marker='o', markersize=15, markerfacecolor="green")
    plt.legend((white_circle, orange_circle, red_circle, gray_circle, green_circle),
               ('Un-explored', 'Frontier', 'Currently Exploring', 'Explored', 'Final Solution'),
               numpoints=1, prop={'size':16}, loc=(.8,.75))
    
    # show the plot. No need to use in notebooks. nx.draw will show the graph itself.
    plt.show()
    
def final_path_colors(initial_node_colors, problem, solution):
    "Return a node_colors dict of the final path provided the problem and solution."
    
    # get initial node colors
    final_colors = dict(initial_node_colors)
    # color all the nodes in solution and starting node to green
    final_colors[problem.initial] = "green"
    for node in solution:
        final_colors[node] = "green"  
    return final_colors

class Problem(object):

    """The abstract class for a formal problem. You should subclass
    this and implement the methods actions and result, and possibly
    __init__, goal_test, and path_cost. Then you will create instances
    of your subclass and solve them with the various search functions."""

    def __init__(self, initial, goal=None):
        """The constructor specifies the initial state, and possibly a goal
        state, if there is a unique goal. Your subclass's constructor can add
        other arguments."""
        self.initial = initial
        self.goal = goal

    def actions(self, state):
        """Return the actions that can be executed in the given
        state. The result would typically be a list, but if there are
        many actions, consider yielding them one at a time in an
        iterator, rather than building them all at once."""
        raise NotImplementedError

    def result(self, state, action):
        """Return the state that results from executing the given
        action in the given state. The action must be one of
        self.actions(state)."""
        raise NotImplementedError

    def goal_test(self, state):
        """Return True if the state is a goal. The default method compares the
        state to self.goal or checks for state in self.goal if it is a
        list, as specified in the constructor. Override this method if
        checking against a single self.goal is not enough."""
        if isinstance(self.goal, list):
            return is_in(state, self.goal)
        else:
            return state == self.goal

    def path_cost(self, c, state1, action, state2):
        """Return the cost of a solution path that arrives at state2 from
        state1 via action, assuming cost c to get up to state1. If the problem
        is such that the path doesn't matter, this function will only look at
        state2.  If the path does matter, it will consider c and maybe state1
        and action. The default method costs 1 for every step in the path."""
        return c + 1

    def value(self, state):
        """For optimization problems, each state has a value.  Hill-climbing
        and related algorithms try to maximize this value."""
        raise NotImplementedError

class GraphProblem(Problem):

    """The problem of searching a graph from one node to another."""

    def __init__(self, initial, goal, graph):
        Problem.__init__(self, initial, goal)
        self.graph = graph

    def actions(self, A):
        """The actions at a graph node are just its neighbors."""
        return list(self.graph.get(A).keys())

    def result(self, state, action):
        """The result of going to a neighbor is just that neighbor."""
        return action

    def path_cost(self, cost_so_far, A, action, B):
        return cost_so_far + (self.graph.get(A, B) or infinity)

    def find_min_edge(self):
        """Find minimum value of edges."""
        m = infinity
        for d in self.graph.graph_dict.values():
            local_min = min(d.values())
            m = min(m, local_min)

        return m

    def h(self, node):
        """h function is straight-line distance from a node's state to goal."""
        locs = getattr(self.graph, 'locations', None)
        if locs:
            if type(node) is str:
                return int(distance(locs[node], locs[self.goal]))

            return int(distance(locs[node.state], locs[self.goal]))
        else:
            return infinity

class Node:

    """A node in a search tree. Contains a pointer to the parent (the node
    that this is a successor of) and to the actual state for this node. Note
    that if a state is arrived at by two paths, then there are two nodes with
    the same state.  Also includes the action that got us to this state, and
    the total path_cost (also known as g) to reach the node.  Other functions
    may add an f and h value; see best_first_graph_search and astar_search for
    an explanation of how the f and h values are handled. You will not need to
    subclass this class."""

    def __init__(self, state, parent=None, action=None, path_cost=0):
        """Create a search tree Node, derived from a parent by an action."""
        self.state = state
        self.parent = parent
        self.action = action
        self.path_cost = path_cost
        self.depth = 0
        if parent:
            self.depth = parent.depth + 1

    def __repr__(self):
        return "<Node {}>".format(self.state)

    def __lt__(self, node):
        return self.state < node.state

    def expand(self, problem):
        """List the nodes reachable in one step from this node."""
        return [self.child_node(problem, action)
                for action in problem.actions(self.state)]

    def child_node(self, problem, action):
        """[Figure 3.10]"""
        next_state = problem.result(self.state, action)
        next_node = Node(next_state, self, action,
                    problem.path_cost(self.path_cost, self.state,
                                      action, next_state))
        return next_node
    
    def solution(self):
        """Return the sequence of actions to go from the root to this node."""
        return [node.action for node in self.path()[1:]]

    def path(self):
        """Return a list of nodes forming the path from the root to this node."""
        node, path_back = self, []
        while node:
            path_back.append(node)
            node = node.parent
        return list(reversed(path_back))

    # We want for a queue of nodes in breadth_first_graph_search or
    # astar_search to have no duplicated states, so we treat nodes
    # with the same state as equal. [Problem: this may not be what you
    # want in other contexts.]

    def __eq__(self, other):
        return isinstance(other, Node) and self.state == other.state

    def __hash__(self):
        return hash(self.state)

class Graph:

    """A graph connects nodes (vertices) by edges (links).  Each edge can also
    have a length associated with it.  The constructor call is something like:
        g = Graph({'A': {'B': 1, 'C': 2})
    this makes a graph with 3 nodes, A, B, and C, with an edge of length 1 from
    A to B,  and an edge of length 2 from A to C.  You can also do:
        g = Graph({'A': {'B': 1, 'C': 2}, directed=False)
    This makes an undirected graph, so inverse links are also added. The graph
    stays undirected; if you add more links with g.connect('B', 'C', 3), then
    inverse link is also added.  You can use g.nodes() to get a list of nodes,
    g.get('A') to get a dict of links out of A, and g.get('A', 'B') to get the
    length of the link from A to B.  'Lengths' can actually be any object at
    all, and nodes can be any hashable object."""

    def __init__(self, graph_dict=None, directed=True):
        self.graph_dict = graph_dict or {}
        self.directed = directed
        if not directed:
            self.make_undirected()

    def make_undirected(self):
        """Make a digraph into an undirected graph by adding symmetric edges."""
        for a in list(self.graph_dict.keys()):
            for (b, dist) in self.graph_dict[a].items():
                self.connect1(b, a, dist)

    def connect(self, A, B, distance=1):
        """Add a link from A and B of given distance, and also add the inverse
        link if the graph is undirected."""
        self.connect1(A, B, distance)
        if not self.directed:
            self.connect1(B, A, distance)

    def connect1(self, A, B, distance):
        """Add a link from A to B of given distance, in one direction only."""
        self.graph_dict.setdefault(A, {})[B] = distance

    def get(self, a, b=None):
        """Return a link distance or a dict of {node: distance} entries.
        .get(a,b) returns the distance or None;
        .get(a) returns a dict of {node: distance} entries, possibly {}."""
        links = self.graph_dict.setdefault(a, {})
        if b is None:
            return links
        else:
            return links.get(b)

    def nodes(self):
        """Return a list of nodes in the graph."""
        s1 = set([k for k in self.graph_dict.keys()])
        s2 = set([k2 for v in self.graph_dict.values() for k2, v2 in v.items()])
        nodes = s1.union(s2)
        return list(nodes)        
        
def UndirectedGraph(graph_dict=None):
    """Build a Graph where every edge (including future ones) goes both ways."""
    return Graph(graph_dict = graph_dict, directed=False)

"""## Mapa que deverá ser percorrido"""

romania_map = UndirectedGraph(dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142)))

romania_map.locations = dict(
    Arad=(91, 492), Bucharest=(400, 327), Craiova=(253, 288),
    Drobeta=(165, 299), Eforie=(562, 293), Fagaras=(305, 449),
    Giurgiu=(375, 270), Hirsova=(534, 350), Iasi=(473, 506),
    Lugoj=(165, 379), Mehadia=(168, 339), Neamt=(406, 537),
    Oradea=(131, 571), Pitesti=(320, 368), Rimnicu=(233, 410),
    Sibiu=(207, 457), Timisoara=(94, 410), Urziceni=(456, 350),
    Vaslui=(509, 444), Zerind=(108, 531))


node_colors = {node: 'white' for node in romania_map.locations.keys()}
node_positions = romania_map.locations
node_label_pos = { k:[v[0],v[1]-10]  for k,v in romania_map.locations.items() }
edge_weights = {(k, k2) : v2 for k, v in romania_map.graph_dict.items() for k2, v2 in v.items()}

romania_graph_data = {  'graph_dict' : romania_map.graph_dict,
                        'node_colors': node_colors,
                        'node_positions': node_positions,
                        'node_label_positions': node_label_pos,
                         'edge_weights': edge_weights
                     }


show_map(romania_graph_data)

"""## Busca em profundidade

Primeiramente vamos implementar a busca em profundidade. Note que esta implementação tem uma pequena variação para não visitar novamente as cidades já visitadas, tendo em vista que temos um grafo, não uma árvore.
"""

def graph_search_for_vis(problem):
    """Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    If two paths reach a state, only use the first one. [Figure 3.7]"""
    # we use these two variables at the time of visualisations
    iterations = 0
    current_node_colors = {}
    node_colors = {k : 'white' for k in problem.graph.nodes()}
    
    frontier = [(Node(problem.initial))]
    explored = set()
    
    # modify the color of frontier nodes to orange
    node_colors[Node(problem.initial).state] = "orange"
    iterations += 1
    current_node_colors = dict(node_colors)
    
    while frontier:
        # Popping first node of stack
        node = frontier.pop()
        
        # modify the currently searching node to red
        node_colors[node.state] = "red"
        iterations += 1
        current_node_colors = dict(node_colors)
        
        if problem.goal_test(node.state):
            # modify goal node to green after reaching the goal
            node_colors[node.state] = "green"
            iterations += 1
            current_node_colors = dict(node_colors)
            return(iterations, current_node_colors, node)
        
        explored.add(node.state)
        frontier.extend(child for child in node.expand(problem)
                        if child.state not in explored and
                        child not in frontier)
        
        for n in frontier:
            # modify the color of frontier nodes to orange
            node_colors[n.state] = "orange"
            iterations += 1
            current_node_colors = dict(node_colors)

        # modify the color of explored nodes to gray
        node_colors[node.state] = "gray"
        iterations += 1
        current_node_colors = dict(node_colors)
                
    return iterations, current_node_colors, node

current_node_colors = {}
romania_problem = GraphProblem('Arad', 'Bucharest', romania_map)

iterations, current_node_colors, node = graph_search_for_vis(romania_problem)

new_romania_graph_data = {  'graph_dict' : romania_map.graph_dict,
                        'node_colors': current_node_colors,
                        'node_positions': node_positions,
                        'node_label_positions': node_label_pos,
                         'edge_weights': edge_weights
                     }
show_map(new_romania_graph_data)

"""Note que as cidades visitadas foram as que estão em cinza, em verde o destino e em laranja as cidades vizinhas fronteiras das que ele passou mas não visitou.

## Busca em largura

Agora vamos implementar a busca em largura, com a mesma restrição anterior.
"""

def breadth_first_search_graph(problem):
    "[Figure 3.11]"
    
    # we use these two variables at the time of visualisations
    iterations = 0
    current_node_colors = {}
    node_colors = {k : 'white' for k in problem.graph.nodes()}
    
    node = Node(problem.initial)
    
    node_colors[node.state] = "red"
    iterations += 1
    current_node_colors = dict(node_colors)
      
    if problem.goal_test(node.state):
        node_colors[node.state] = "green"
        iterations += 1
        current_node_colors = dict(node_colors)
        return(iterations, current_node_colors, node)
    
    frontier = deque([node])
    
    # modify the color of frontier nodes to blue
    node_colors[node.state] = "orange"
    iterations += 1
    current_node_colors = dict(node_colors)
        
    explored = set()
    while frontier:
        node = frontier.popleft()
        node_colors[node.state] = "red"
        iterations += 1
        current_node_colors = dict(node_colors)
        
        explored.add(node.state)     
        
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                if problem.goal_test(child.state):
                    node_colors[child.state] = "green"
                    iterations += 1
                    current_node_colors = dict(node_colors)
                    return(iterations, current_node_colors, child)
                frontier.append(child)

                node_colors[child.state] = "orange"
                iterations += 1
                current_node_colors = dict(node_colors)
                    
        node_colors[node.state] = "gray"
        iterations += 1
        current_node_colors = dict(node_colors)
    return iterations, current_node_colors, node

current_node_colors = {}
romania_problem = GraphProblem('Arad', 'Bucharest', romania_map)

iterations, current_node_colors, node = breadth_first_search_graph(romania_problem)

new_romania_graph_data = {  'graph_dict' : romania_map.graph_dict,
                        'node_colors': current_node_colors,
                        'node_positions': node_positions,
                        'node_label_positions': node_label_pos,
                         'edge_weights': edge_weights
                     }
show_map(new_romania_graph_data)

def breadth_first_search_graph(problem):
    "[Figure 3.11]"
    
    # we use these two variables at the time of visualisations
    iterations = 0
    all_node_colors = []
    node_colors = {k : 'white' for k in problem.graph.nodes()}
    
    node = Node(problem.initial)
    
    node_colors[node.state] = "red"
    iterations += 1
    all_node_colors.append(dict(node_colors))
      
    if problem.goal_test(node.state):
        node_colors[node.state] = "green"
        iterations += 1
        all_node_colors.append(dict(node_colors))
        return(iterations, all_node_colors, node)
    
    frontier = deque([node])
    
    # modify the color of frontier nodes to blue
    node_colors[node.state] = "orange"
    iterations += 1
    all_node_colors.append(dict(node_colors))
        
    explored = set()
    while frontier:
        node = frontier.popleft()
        node_colors[node.state] = "red"
        iterations += 1
        all_node_colors.append(dict(node_colors))
        
        explored.add(node.state)     
        
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                if problem.goal_test(child.state):
                    node_colors[child.state] = "green"
                    iterations += 1
                    all_node_colors.append(dict(node_colors))
                    return(iterations, all_node_colors, child)
                frontier.append(child)

                node_colors[child.state] = "orange"
                iterations += 1
                all_node_colors.append(dict(node_colors))
                    
        node_colors[node.state] = "gray"
        iterations += 1
        all_node_colors.append(dict(node_colors))
    return None

def graph_search_for_vis(problem):
    """Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    If two paths reach a state, only use the first one. [Figure 3.7]"""
    # we use these two variables at the time of visualisations
    iterations = 0
    all_node_colors = []
    node_colors = {k : 'white' for k in problem.graph.nodes()}
    
    frontier = [(Node(problem.initial))]
    explored = set()
    
    # modify the color of frontier nodes to orange
    node_colors[Node(problem.initial).state] = "orange"
    iterations += 1
    all_node_colors.append(dict(node_colors))
      
    while frontier:
        # Popping first node of stack
        node = frontier.pop()
        
        # modify the currently searching node to red
        node_colors[node.state] = "red"
        iterations += 1
        all_node_colors.append(dict(node_colors))
        
        if problem.goal_test(node.state):
            # modify goal node to green after reaching the goal
            node_colors[node.state] = "green"
            iterations += 1
            all_node_colors.append(dict(node_colors))
            return(iterations, all_node_colors, node)
        
        explored.add(node.state)
        frontier.extend(child for child in node.expand(problem)
                        if child.state not in explored and
                        child not in frontier)
        
        for n in frontier:
            # modify the color of frontier nodes to orange
            node_colors[n.state] = "orange"
            iterations += 1
            all_node_colors.append(dict(node_colors))

        # modify the color of explored nodes to gray
        node_colors[node.state] = "gray"
        iterations += 1
        all_node_colors.append(dict(node_colors))
        
    return None


def depth_first_graph_search(problem):
    """Search the deepest nodes in the search tree first."""
    iterations, all_node_colors, node = graph_search_for_vis(problem)
    return(iterations, all_node_colors, node)

"""## Código Adicional"""

def best_first_graph_search_for_vis(problem, f):
    """Search the nodes with the lowest f scores first.
    You specify the function f(node) that you want to minimize; for example,
    if f is a heuristic estimate to the goal, then we have greedy best
    first search; if f is node.depth then we have breadth-first search.
    There is a subtlety: the line "f = memoize(f, 'f')" means that the f
    values will be cached on the nodes as they are computed. So after doing
    a best first search you can examine the f values of the path returned."""
    
    # we use these two variables at the time of visualisations
    iterations = 0
    all_node_colors = []
    node_colors = {k : 'white' for k in problem.graph.nodes()}
    
    f = memoize(f, 'f')
    node = Node(problem.initial)
    
    node_colors[node.state] = "red"
    iterations += 1
    all_node_colors.append(dict(node_colors))
    
    if problem.goal_test(node.state):
        node_colors[node.state] = "green"
        iterations += 1
        all_node_colors.append(dict(node_colors))
        return(iterations, all_node_colors, node)
    
    frontier = PriorityQueue('min', f)
    frontier.append(node)
    
    node_colors[node.state] = "orange"
    iterations += 1
    all_node_colors.append(dict(node_colors))
    
    explored = set()
    while frontier:
        node = frontier.pop()
        
        node_colors[node.state] = "red"
        iterations += 1
        all_node_colors.append(dict(node_colors))
        
        if problem.goal_test(node.state):
            node_colors[node.state] = "green"
            iterations += 1
            all_node_colors.append(dict(node_colors))
            return(iterations, all_node_colors, node)
        
        explored.add(node.state)
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                frontier.append(child)
                node_colors[child.state] = "orange"
                iterations += 1
                all_node_colors.append(dict(node_colors))
            elif child in frontier:
                incumbent = frontier[child]
                if f(child) < (incumbent):
                    del frontier[incumbent]
                    frontier.append(child)
                    node_colors[child.state] = "orange"
                    iterations += 1
                    all_node_colors.append(dict(node_colors))

        node_colors[node.state] = "gray"
        iterations += 1
        all_node_colors.append(dict(node_colors))
    return None




def memoize(fn, slot=None, maxsize=32):
    """Memoize fn: make it remember the computed value for any argument list.
    If slot is specified, store result in that slot of first argument.
    If slot is false, use lru_cache for caching the values."""
    if slot:
        def memoized_fn(obj, *args):
            if hasattr(obj, slot):
                return getattr(obj, slot)
            else:
                val = fn(obj, *args)
                setattr(obj, slot, val)
                return val
    else:
        @functools.lru_cache(maxsize=maxsize)
        def memoized_fn(*args):
            return fn(*args)

    return memoized_fn



def distance(a, b):
    """The distance between two (x, y) points."""
    xA, yA = a
    xB, yB = b
    return np.hypot((xA - xB), (yA - yB))




class PriorityQueue:
    """A Queue in which the minimum (or maximum) element (as determined by f and
    order) is returned first.
    If order is 'min', the item with minimum f(x) is
    returned first; if order is 'max', then it is the item with maximum f(x).
    Also supports dict-like lookup."""

    def __init__(self, order='min', f=lambda x: x):
        self.heap = []
        if order == 'min':
            self.f = f
        elif order == 'max':  # now item with max f(x)
            self.f = lambda x: -f(x)  # will be popped first
        else:
            raise ValueError("Order must be either 'min' or 'max'.")

    def append(self, item):
        """Insert item at its correct position."""
        heapq.heappush(self.heap, (self.f(item), item))

    def extend(self, items):
        """Insert each item in items at its correct position."""
        for item in items:
            self.append(item)

    def pop(self):
        """Pop and return the item (with min or max f(x) value)
        depending on the order."""
        if self.heap:
            return heapq.heappop(self.heap)[1]
        else:
            raise Exception('Trying to pop from empty PriorityQueue.')

    def __len__(self):
        """Return current capacity of PriorityQueue."""
        return len(self.heap)

    def __contains__(self, key):
        """Return True if the key is in PriorityQueue."""
        return any([item == key for _, item in self.heap])

    def __getitem__(self, key):
        """Returns the first value associated with key in PriorityQueue.
        Raises KeyError if key is not present."""
        for value, item in self.heap:
            if item == key:
                return value
        raise KeyError(str(key) + " is not in the priority queue")

    def __delitem__(self, key):
        """Delete the first occurrence of key."""
        try:
            del self.heap[[item == key for _, item in self.heap].index(True)]
        except ValueError:
            raise KeyError(str(key) + " is not in the priority queue")
        heapq.heapify(self.heap)


# ______________________________________________________________________________
# Useful Shorthands


class Bool(int):
    """Just like `bool`, except values display as 'T' and 'F' instead of 'True' and 'False'."""
    __str__ = __repr__ = lambda self: 'T' if self else 'F'


T = Bool(True)
F = Bool(False)

"""## Fim do Código Adicional"""

all_node_colors = []
romania_problem = GraphProblem('Arad', 'Bucharest', romania_map)
display_visual(romania_graph_data,  
               algorithm=depth_first_graph_search, 
               problem=romania_problem)

def greedy_best_first_search(problem, h=None):
    """Greedy Best-first graph search is an informative searching algorithm with f(n) = h(n).
    You need to specify the h function when you call best_first_search, or
    else in your Problem subclass."""
    h = memoize(h or problem.h, 'h')
    iterations, all_node_colors, node = best_first_graph_search_for_vis(problem, lambda n: h(n))
    return(iterations, all_node_colors, node)

all_node_colors = []
romania_problem = GraphProblem('Arad', 'Bucharest', romania_map)
display_visual(romania_graph_data,  
               algorithm=greedy_best_first_search, 
               problem=romania_problem)

"""### Agora é sua vez

Para cada uma das 3 abordagens de busca (profundidade, largura e gulosa), verifique o número de iterações e o tempo que o algoritmo demorou para executar.  Responda: **Para este conjunto de dados, qual algoritmo é melhor?**

Dica 1 - para pegar as cidades, basta pegar as chaves do dicionário de localizações:

```
list(romania_map.locations.keys())
```

Dica 2 - para medir o tempo de cada execução, basta utilizar este código: 
```
start_time = time.time()
# função de busca 
elapsed_time = time.time() - start_time
```


## Atividade Bonus
Para deixar sua análise mais interessante, faça 30 medições para cada par de cidades diferentes, ou seja, entre Arad e todas as outras cidades, entre Zerind e todas as outras cidades, etc.

Após medir o número de iterações e o tempo de execução de cada algoritmo, veja a média, mediana, desvio padrão para cada um dos algoritmos e verifique se a resposta anterior mudou.
"""

romania_problem = GraphProblem('Arad', 'Bucharest', romania_map)

#Gulosa
start_time = time.time()
iterations, all_node_colors, node= greedy_best_first_search(romania_problem)
elapsed_time = time.time() - start_time

print(iterations)
print(elapsed_time)

#Profundidade
start_time = time.time()
iterations, current_node_colors, node = graph_search_for_vis(romania_problem)
elapsed_time = time.time() - start_time

print(iterations)
print(elapsed_time)

#Largura
start_time = time.time()
iterations, current_node_colors, node = breadth_first_search_graph(romania_problem)
elapsed_time = time.time() - start_time

print(iterations)
print(elapsed_time)

"""Resposta: Após executar as 3 abordagens de busca 10 vezes, calculei a média e percebi que para esse exemplo a busca em largura se saiu bem melhor em questão de tempo, sendo o número de iterações maior que a busca gulosa.

> Médias:

Gulosa -> 0.00036554336547851564

Profundidade -> 0.0005298614501953125

Largura -> 0.00024962425231933594

> Iterações:

Gulosa -> 17

Profundidade -> 40

Largura -> 21


Os tempos de execução estão abaixo na seguinte ordem

1.   Gulosa
2.   Profundidade
3.   Largura



```
0.0008232593536376953
0.00047469139099121094
0.00028252601623535156

0.0004315376281738281
0.00029969215393066406
0.00025343894958496094

0.00027108192443847656
0.00022029876708984375
0.000202178955078125

0.00028443336486816406
0.00019621849060058594
0.0002453327178955078

0.00028324127197265625
0.0024645328521728516
0.00028395652770996094

0.0003314018249511719
0.0003116130828857422
0.0002913475036621094

0.0003216266632080078
0.0003521442413330078
0.00017142295837402344

0.0002925395965576172
0.0003216266632080078
0.00015997886657714844

0.0003688335418701172
0.0003390312194824219
0.00035858154296875

0.0002474784851074219
0.00031876564025878906
0.0002474784851074219

Resposta (Bônus): Usei o software R para os cálculos. Observei que a busca em largura continou obtendo os melhores tempos, sendo o que possui a menor média, como também o menor desvio padrão. No quesito iterações, busca gulosa continua apresentando geralmente o menor número. As 30 medições foram:

Formato: CIDADE1 - CIDADE2 (N_ITERAÇÃO GULOSA, N_ITERAÇÃO PROFUNDIDADE, N_ITERAÇÃO LARGURA) 

1.   Arad - Neamt (35,93,56)
2.   Arad - Eforie (29,75,53)
3.   Arad - Craiova (18,28,24)
4.   Arad - Vaslui (26,81,42)
5.   Arad - Iasi (29,87,50)
6.   Arad - Urziceni (22,61,31)
7.   Arad - Pitesti (22,34,25)
8.   Arad - Craiova (18,28,24)
9.   Arad - Eforie (29,75,53)
10.  Arad - Giurgiu (22,55,32)
11.  Mehadia - Vaslui (30,86,44)
12.  Arad - Rimnicu (14,98,13)
13.  Lugoj - Vaslui (30,90,44)
14.  Rimnicu - Eforie (24,43,53)
15.  Sibiu - Eforie (25,54,53)
16.  Zerind - Neamt (36,73,56)
17.  Zerind - Eforie (31,55,53)
18.  Zerind - Giurgiu (24,35,32) 
19.  Neamt - Bucharest (17,23,13)
20.  Drobeta - Eforie (27,91,53)
21.  Oradea - Eforie (28,58,53)
22.  Pitesti - Oradea (17,46,21)
23.  Urziceni - Oradea (22,84,42)
24.  Lugoj - Iasi (33,95,50)
25.  Urziceni - Timisoara (26,77,49)
26.  Vaslui - Rimnicu (25,41,25)
27.  Hirsova - Arad (25,94,41)
28.  Craiova - Neamt (30,109,56)
29.  Pitesti - Neamt (27,92,54)
30.  Timisoara - Iasi (44,95,56)



Abaixo o cálculo das estatísticas

```
> gulosa <- c(0.0008206367492675781,0.0004673004150390625,0.0003299713134765625,
+ 0.0005614757537841797,0.0006411075592041016,0.00036072731018066406,0.0005984306335449219,
+ 0.0003993511199951172,0.000400543212890625,0.0005068778991699219,0.0006475448608398438,
+ 0.0005483627319335938,0.0056459903717041016,0.00040602684020996094,0.001378774642944336,
+ 0.001445770263671875,0.0005075931549072266,0.0004067420959472656,0.0005667209625244141,
+ 0.00046944618225097656,0.0003879070281982422,0.00037670135498046875,0.0003573894500732422,
+ 0.0006625652313232422,0.0003795623779296875,0.0006270408630371094,0.0006246566772460938,
+ 0.0006608963012695312,0.0004265308380126953,0.0007407665252685547)
> 
> profundidade <- c(0.0007770061492919922,0.0005135536193847656,0.00033092498779296875,
+ 0.0005123615264892578,0.0005357265472412109,0.0004830360412597656,0.0003483295440673828,
+ 0.000263214111328125,0.0003726482391357422,0.0004203319549560547,0.001222372055053711,
+ 0.0005245208740234375,0.012543678283691406,0.00023889541625976562,0.00037980079650878906,
+ 0.004997968673706055,0.0003345012664794922,0.0003421306610107422,0.00023746490478515625,
+ 0.0004241466522216797,0.00030422210693359375, 0.0002803802490234375,0.0005061626434326172,
+ 0.000576019287109375,0.000492095947265625,0.00040030479431152344,0.0005700588226318359,
+ 0.0005965232849121094,0.0006644725799560547,0.001988649368286133)
> 
> largura <- c(0.0003254413604736328,0.0004799365997314453,0.00035381317138671875,
+ 0.0008101463317871094,0.0005266666412353516,0.0004878044128417969,0.0003330707550048828,
+ 0.0003962516784667969,0.00033593177795410156,0.00030541419982910156,0.00045228004455566406,
+ 0.00016808509826660156,0.0004546642303466797,0.0002999305725097656,0.00031685829162597656,
+ 0.0003368854522705078,0.0003349781036376953,0.00038886070251464844,0.000202178955078125,
+ 0.00048041343688964844,0.0003323554992675781,0.00023365020751953125,0.0004329681396484375,
+ 0.00044918060302734375,0.00034117698669433594,0.0003075599670410156,0.0004868507385253906,
+ 0.0004715919494628906,0.0015597343444824219,0.0006632804870605469
+ )
> summary(gulosa)
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
0.0003300 0.0004019 0.0005280 0.0007451 0.0006459 0.0056460 
> summary(profundidade)
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
0.0002375 0.0003437 0.0004876 0.0010727 0.0005745 0.0125437 
> summary(largura)
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
0.0001681 0.0003272 0.0003713 0.0004356 0.0004779 0.0015597 
> sd(gulosa)
[1] 0.000961468
> sd(profundidade)
[1] 0.002339632
> sd(largura)
[1] 0.0002484905
```
"""